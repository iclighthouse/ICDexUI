<template>
  <div>
    <div v-show="step === 1">
      <div class="step-title">Select Import Type</div>
      <div class="connect-list">
        <div class="connect-list-item" @click="step++">
          <span><a-icon type="key" style="color: #1996c4" /></span>
          <dl>
            <dt>Import using a seed phrase</dt>
          </dl>
        </div>
        <div class="connect-list-item">
          <span><a-icon type="file" style="color: #1996c4" /></span>
          <dl>
            <dt>Import using a PEM file</dt>
          </dl>
          <input type="file" accept=".pem" @change="onchangeFile" />
        </div>
      </div>
      <div class="mnemonic-phrase-bottom">
        <button type="button" @click="back">Back</button>
      </div>
    </div>
    <div v-show="step === 2">
      <div class="step-title">Confirm your mnemonic seed</div>
      <p class="mnemonic-tip">Please confirm your word seed phrase:</p>
      <div class="mnemonic-wrap">
        <!--<div
					class="mnemonic-item"
					v-for="(item, index) in checkMnemonicList"
					:key="index"
				>
					<span class="mnemonic-num">{{ index + 1 }}.</span>
					<input type="text" v-model="checkMnemonicList[index]" />
				</div>-->
        <a-textarea
          v-model="mnemonic"
          :autoSize="{ minRows: 4 }"
          placeholder="Confirm your mnemonic seed"
          autocomplete="new-password"
        ></a-textarea>
      </div>
      <div class="mnemonic-error" v-show="showErr">
        The mnemonic you entered is not valid
      </div>
      <div class="mnemonic-phrase-bottom">
        <button @click="confirmMnemonic">Back</button
        ><button class="default" @click="validMnemonic">Next Step</button>
      </div>
    </div>
    <div v-show="step === 3">
      <confirm-password
        :identity="identity"
        :mnemonic="mnemonic"
        @confirmPasswordBack="confirmPasswordBack"
      ></confirm-password>
    </div>
  </div>
</template>

<script lang="ts">
import { Component, Vue } from 'vue-property-decorator';
import ConfirmPassword from '@/views/login/components/ConfirmPassword.vue';
import { Ed25519KeyIdentity } from '@dfinity/identity';
import { Secp256k1KeyIdentity } from '@dfinity/identity-secp256k1';
import { Identity } from '@dfinity/agent';

const ethers = require('ethers');
const EC = require('elliptic').ec;
const KeyEncoder = require('key-encoder').default;
const keyEncoder = new KeyEncoder('secp256k1');
// Create and initialize EC context
// (better do it once and reuse it)
const ec = new EC('secp256k1');
const {
  key_new,
  key_to_pub_key,
  seed_from_pem
} = require('@dfinity/rosetta-client');

@Component({
  name: 'ExistingWallet',
  components: {
    ConfirmPassword
  }
})
export default class extends Vue {
  public step = 1;
  public mnemonic = '';
  public identity: Identity = null;
  public showErr = false;
  public validMnemonic(): void {
    const mnemonic = this.mnemonic
      .replace(/^\s+|\s+$/g, '')
      .replace(/\s+/g, ' ');
    this.showErr = !ethers.utils.isValidMnemonic(mnemonic);
    if (!this.showErr) {
      this.step++;
    }
  }
  public confirmMnemonic(): void {
    this.step--;
    this.showErr = false;
    this.mnemonic = '';
  }
  public back(): void {
    this.$emit('back');
    this.step = 1;
  }
  public confirmPasswordBack(): void {
    this.step--;
  }
  public onchangeFile(e: Event): void {
    const target = e.target as HTMLInputElement;
    const file = target.files[0];
    let reader = new FileReader();
    reader.readAsText(file, 'UTF-8');
    reader.onload = async (evt) => {
      const rawPrivateKey = evt.target.result as string;
      this.identityFromPem(rawPrivateKey);
    };
    target.value = '';
  }
  public identityFromPem(rawPrivateKey: string): void {
    if (
      rawPrivateKey.startsWith('-----BEGIN EC PARAMETERS-----') ||
      rawPrivateKey.startsWith('-----BEGIN EC PRIVATE KEY-----')
    ) {
      // EC secp256k1
      const derPrivateKey = keyEncoder.encodePrivate(
        rawPrivateKey,
        'pem',
        'raw'
      );
      const key = ec.keyFromPrivate(derPrivateKey, 'hex');
      const publicKey = key.getPublic('hex');
      this.identity = Secp256k1KeyIdentity.fromJSON(
        JSON.stringify([publicKey, derPrivateKey])
      );
    } else {
      // The PEM file generated by `dfx new`
      // Only supports PEM files generated by dfx at the moment.
      const seed = seed_from_pem(rawPrivateKey);
      const privateKey = key_new(seed);
      const publicKey = key_to_pub_key(privateKey);
      this.identity = Ed25519KeyIdentity.fromKeyPair(publicKey, privateKey);
    }
    this.step = 3;
  }
}
</script>

<style scoped lang="scss">
.mnemonic-wrap {
  width: 100%;
  margin: 0 auto 30px;
}
.connect-list-item {
  position: relative;
  input {
    position: absolute;
    left: 50px;
    right: 0;
    top: 0;
    bottom: 0;
    cursor: pointer;
    opacity: 0;
  }
}
</style>
